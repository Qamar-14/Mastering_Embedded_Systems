/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "GPIO_DRIVER/gpio.h"
#include "USART_DRIVER/usart.h"
#include "SPI_DRIVER/spi.h"


#define MCU_ACT_AS_MASTER
//#define MCU_ACT_AS_SLAV
uint16_t key ;

void SPI_IRQ_CallBack(S_IRQ_SRC irq_src)
{
#ifdef MCU_ACT_AS_SLAV

	if(irq_src.RXNE)
	{
		key = 0x0f;
		MCAL_SPI_TX_RX(SPI1, &key, Polling_enable);
		MCAL_UART_SEND_DATA(USART1, &key, ENABLE);
	}
#endif
}

void USART_IRQ_CallBack(void)
{
	#ifdef MCU_ACT_AS_MASTER
	MCAL_UART_RECEIVE_DATA(USART1, &key, DISABLE);
	MCAL_UART_SEND_DATA(USART1, &key, ENABLE);

	//Send to SPI
	MCAL_GPIO_WRITE_PIN(GPIOA, GPIO_PIN4, 0);
	MCAL_SPI_TX_RX(SPI1, &key, Polling_enable);
	MCAL_GPIO_WRITE_PIN(GPIOA, GPIO_PIN4, 1);
	#endif
}

void clock_init()

{

	//Enable clock GPIOA
	RCC_GPIOA_CLK_EN();
	//Enable clock GPIOB
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();

}



int main(void)
{
	clock_init();
	GPIO_PIN_CONFIG_t PinConfig;

	// =================== UART INIT =====================
	UART_Config_t UART ;
	UART.BaudRate = UART_BaudRate_115200 ;
	UART.FlowCTRL = UART_FLOWCTRL_NONE ;
	UART.IRQ_ENABLE = UART_IRQ_ENABLE_RXNEIE ;
	UART.USART_MODE = UART_MODE_RX_TX ;
	UART.Parity = UART_PARITY_NONE ;
	UART.Payload_length = UART_PayloadLength_8B ;
	UART.StopBits = UART_StopBit_1 ;
	UART.P_IRQ_CALLBACK = USART_IRQ_CallBack ;

	MCAL_UART_INIT(USART1, &UART);
	MCAL_UART_GPIO_SET_PINS(USART1);



	// =================== SPI INIT =====================
	//   PA4 : SPI1_NSS
	//   PA5 : SPI1_SCK
	//	 PA6 : SPI1_MISO
	//   PA7 : SPI1_MOSI
	SPI_Config_t SPI;

	// common configuration for master and slave
	SPI.CLK_PHASE = SPI_CLKPHASE_2EDGE_FIRST_DATA_CAPTURE_EDGE;
	SPI.CLK_POLARITY = SPI_CLKPOLARITY_HIGH_WHEN_IDLE;
	SPI.DATA_SZ = SPI_DATA_SIZE_8B;
	SPI.FRAME_FORMAT = SPI_FRAME_FORMAT_MSB;
	SPI.SPI_BAUDRATE_PRESCALAR = SPI_BAUDRATE_PRESCALAR_8;
	SPI.COMM_MODE = SPI_DIRECTION_2LINES;


	#ifdef MCU_ACT_AS_MASTER

	SPI.DEVICE_MODE = SPI_DEVICE_MODE_MASTER;
	SPI.IRQ_ENABLE = SPI_IRQ_ENABLE_NONE;
	SPI.NSS = SPI_NSS_SW_InternalSoft_set;
	SPI.P_SPI_IRQ_CALLBACK = NULL;

	// configure SS on PA4 by GPIO
    PinConfig.GPIO_PIN_NO = GPIO_PIN4;
    PinConfig.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
    PinConfig.GPIO_OUTPUT_SPEED = GPIO_SPEED_10MHZ;
    MCAL_GPIO_Init(GPIOA, &PinConfig);


	// Force the Slave Select (HIGH) for idle Mode
	MCAL_GPIO_WRITE_PIN(GPIOA, GPIO_PIN4, 1);

	#endif

	#ifdef MCU_ACT_AS_SLAVE
	SPI.DEVICE_MODE = SPI_DEVICE_MODE_SLAVE;
	SPI.IRQ_ENABLE = SPI_IRQ_ENABLE_RXNEIE;
	SPI.NSS = SPI_NSS_HW_SLAVE;
	SPI.P_SPI_IRQ_CALLBACK = USART_IRQ_CallBack;

	#endif


	MCAL_SPI_INIT(SPI1, &SPI);
	MCAL_SPI_GPIO_SET_PINS(SPI1);


	while(1)
	{

	}
}



